====== exercise 1 =======
Assuming an underlying interpreter that is call by value, does the meta-circular interpreter evaluate sub-expressions, in an application, from left to right or from right to left?

The meta-circular interpreter evaluates sub-expressions from left to right, as the interpreter evaluates though the first part of the argument, afterwards it evaluates though the second part of the argument, as the nature of call by value, the value of the first evaluation of the arguments are passed throughout the whole procedure.

To show this is true, we have tested it by evaluating a simple expression and a complex expression as argument to a procedure. Then by timing the execution, it's possible to see which expression is evaluated first. The test is 

"(interpret `(+ (time 1) (time (, representation-of-interpret (, representation-of-interpret (, representation-of-interpret ' (+12 3)))))))"

and the result is 

(time (eval (time_1 e) ...))
    no collections
    0 ms elapsed cpu time
    0 ms elapsed real time
    0 bytes allocated
(time (eval (time_1 e) ...))
    no collections
    0 ms elapsed cpu time
    0 ms elapsed real time
    30144 bytes allocated
    
 It's clear to see that the expression is evaluated from left to right, as the (time 1) which doesn't allocated anything is evaluated first.

=====================

====== exercise 2 =======
What do you make of Brynja¡¯s question, at the end of the section about call by name, piled on?
285246006/1000/60/60/24=3.3 days
The tower of interpreters is slow, and a salute to Olivier, who used 3 days to prove a point.
When look at the efficiency, we took the overall time and divide it with sum of time from both sets, and the result became ~100 for 0 height, ~74 for 1 height and ~70 for 2 height. So the efficiency was getting better the more height we get which is very interesting as the running time of multiple height escalates exponentially.
======================  
